require_relative 'player'
require_relative 'board'
require_relative 'cli_interface'

class Computer < Player
  attr_reader :board

  def initialize(mark, ui, board)
    super(mark, ui)
    @board = board
    @ui = CliInterface.new(Kernel, Kernel)
  end

  def next_move
    ui.computer_move
    free_positions.shuffle.first
  end

  def minimax(board, current_mark)
    if board.win?(switch_mark(current_mark))
      return -1
    elsif board.win?(current_mark)
      return 1
    elsif board.tie?
      return 0
    else
      if current_mark == mark
        best_value = 100

        free_positions.each do |position|
          board.set_mark(switch_mark(current_mark), position)

          result = minimax(new_board, switch_mark(current_mark))
          puts "trace"

          @ui.display_board(board.board)
          puts "result #{result}"

          puts "trace"

          board.set_mark(position, position)

          best_value = best_value > result ? result : best_value
        end

        return best_value
      else
        best_value = -100

        free_positions.each do |position|
          new_board = Board.new
          new_board = board
          new_board.set_mark(switch_mark(current_mark), position)

          result = minimax(new_board, switch_mark(current_mark))

          best_value = best_value < result ? result : best_value
        end

        return best_value
      end
    end

  end

  def min(first, second)
    if first < second
      first
    else
      second
    end
  end

  def switch_mark(mark)
    if mark == Mark::ROUND
      Mark::CROSS
    else
      Mark::ROUND
    end
  end

  private

  def free_positions
    board.board.flatten.select { |cell| cell.is_a?(Integer) }
  end
end
